= ResuMe - Developer Guide
:site-section: DeveloperGuide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: full
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:warning-caption: :warning:
endif::[]
:repoURL: https://github.com/AY1920S2-CS2103T-F10-1/main

By: `Team F10-1`      Since: `Jan 2020`

== Setting up

Refer to the guide <<SettingUp#, here>>.

== Design

[[Design-Architecture]]
=== Architecture

.Architecture Diagram
image::ArchitectureDiagram.png[]

The *_Architecture Diagram_* given above explains the high-level design of the App. Given below is a quick overview of each component.

[TIP]
The `.puml` files used to create diagrams in this document can be found in the link:{repoURL}/docs/diagrams/[diagrams] folder.
Refer to the <<UsingPlantUml#, Using PlantUML guide>> to learn how to create and edit diagrams.

`Main` has two classes called link:{repoURL}/src/main/java/seedu/address/Main.java[`Main`] and link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp`]. It is responsible for,

* At app launch: Initializes the components in the correct sequence, and connects them up with each other.
* At shut down: Shuts down the components and invokes cleanup method where necessary.

<<Design-Commons,*`Commons`*>> represents a collection of classes used by multiple other components.
The following class plays an important role at the architecture level:

* `LogsCenter` : Used by many classes to write log messages to the App's log file.

The rest of the App consists of four components.

* <<Design-Ui,*`UI`*>>: The UI of the App.
* <<Design-Logic,*`Logic`*>>: The command executor.
* <<Design-Model,*`Model`*>>: Holds the data of the App in-memory.
* <<Design-Storage,*`Storage`*>>: Reads data from, and writes data to, the hard disk.

Each of the four components

* Defines its _API_ in an `interface` with the same name as the Component.
* Exposes its functionality using a `{Component Name}Manager` class.

For example, the `Logic` component (see the class diagram given below) defines it's API in the `Logic.java` interface and exposes its functionality using the `LogicManager.java` class.

.Class Diagram of the Logic Component
image::LogicClassDiagram.png[]

[discrete]
==== How the architecture components interact with each other

The _Sequence Diagram_ below shows how the components interact with each other for the scenario where the user issues the command `delete 1 i/ ski`.

.Component interactions for `delete 1 i/ ski` command

image::ArchitectureSequenceDiagram.png[]

[discrete]
==== How the architecture components interact at start up

The _Sequence Diagram_ below shows how the components interact with each other at start up.

.Component interactions for initialisation

image::ArchitectureInitSequenceDiagram.png[]

The sections below give more details of each component.


[[Design-Ui]]
=== UI component

.Structure of the UI Component
image::UiClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/address/ui/Ui.java[`Ui.java`]

The UI consists of a `MainWindow` that is made up of parts e.g.`CommandBox`, `ResultDisplay`, `ItemDisplay`, `PersonListPanel`, `StatusBarFooter` etc. All these, including the `MainWindow`, inherit from the abstract `UiPart` class.

The `UI` component uses JavaFx UI framework. The layout of these UI parts are defined in matching `.fxml` files that are in the `src/main/resources/view` folder. For example, the layout of the link:{repoURL}/src/main/java/seedu/address/ui/MainWindow.java[`MainWindow`] is specified in link:{repoURL}/src/main/resources/view/MainWindow.fxml[`MainWindow.fxml`]

The `UI` component,

* Executes user commands using the `Logic` component.
* Listens for changes to `Model` data so that the UI can be updated with the modified data.
* Responds to events raised by various commands and the UI can be updated accordingly.

// tag::logic[]
[[Design-Logic]]
=== Logic component

[[fig-LogicClassDiagram]]
.Structure of the Logic Component
image::LogicClassDiagram.png[]

*API* :
link:{repoURL}/src/main/java/seedu/address/logic/Logic.java[`Logic.java`]

.  `Logic` uses the `ResumeBookParser` class to parse the user command.
.  This results in a `Command` object which is executed by the `LogicManager`.
.  The command execution can affect the `Model` (e.g. adding a new resume).
.  The result of the command execution is encapsulated as a `CommandResult` object which is passed back to the `Ui`.
.  In addition, the `CommandResult` object can also instruct the `Ui` to perform certain actions, such as displaying help to the user.

Given below is the Sequence Diagram for interactions within the `Logic` component for the `execute("delete 1 i/ res")` API call.

.Interactions Inside the Logic Component for the `delete 1` Command
image::DeleteSequenceDiagram.png[]

NOTE: The lifeline for `DeleteCommandParser` should end at the destroy marker (X) but due to a limitation of PlantUML, the lifeline reaches the end of diagram.
// end::logic[]

// tag::model[]
[[Design-Model]]
=== Model component

// TODO: Fix diagram layout
.Structure of the Model Component
image::ModelClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/address/model/Model.java[`Model.java`]

The `Model`,

* stores a `UserPref` object that represents the user's preferences.
* stores the Resume Book data.
* exposes an unmodifiable `ObservableList<Item>` that can be 'observed' e.g. the UI can be bound to this list so that the UI automatically updates when the data in the list change.
* does not depend on any of the other three components.

[NOTE]
As a more OOP model, we can store a `Tag` list in `Resume Book`, which `Item` can reference. This would allow `Resume Book` to only require one `Tag` object per unique `Tag`, instead of each `Item` needing their own `Tag` object. An example of how such a model may look like is given below. +
 +
image:BetterModelClassDiagram.png[]

// end::model[]

[[Design-Storage]]
=== Storage component

.Structure of the Storage Component
image::StorageClassDiagram.png[]

*API* : link:{repoURL}/src/main/java/seedu/address/storage/Storage.java[`Storage.java`]

The `Storage` component,

* can save `UserPref` objects in json format and read it back.
* can save the Resume Book data in json format and read it back.

[[Design-Commons]]
=== Common classes

Classes used by multiple components are in the `seedu.resumebook.commons` package.

== Implementation

This section describes some noteworthy details on how certain features are implemented.

// tag::redit[]
=== Resume Edit feature
==== Proposed Implementation
The Resume Edit feature or `redit` allows users to edit which `Item` belongs to the `Resume` (for example, adding a `Skill` item or removing an `Internship` item).
It is not to be confused with the `edit` command, which simply modifies the fields of an `Item`.

The `redit` command is facilitated by `ResumeEditCommand`, which extends `Command`.
Therefore, like any other `Command` classes, it will have an `execute` method.

===== Adding into the resume
The following screenshot illustrates what happens when we use `redit` to add item into the resume. The numbers in the command represent the index of the item in the list. After the end of the command, the number of item in the resume would have increased.

image::ReditAddIntoResume.png[][AddIntoResume,442,337]

For modifications and removal of item from the resume, all we have to do is to run the same command again, specifying which item we want to *retain* in the resume.

===== Removing all from the resume
The following sreenshot illustrates what happens if you want to remove all the items in the resume, starting from a an already-filled resume:

image::ReditRemoveEverything.png[][RemoveEverything,442,337]

===== Removing some from the resume
And the following screenshot illustrates what happens if you want to remove some items:

image::ReditWantSomeThings.png[][WantSomeThings,442,337]

===== Changing content using tags
On top of these methods to change the content of the resume, `redit` can also make changes to the resume by making use of tags.
Regardless of what the original content is, after running the command, the resume will then only have items with the desired tags.

An example is shown in the following screenshot:

image::ReditTags.png[][ReditWithTags,442,337]

==== Design Considerations
===== Aspect: Whether `ResumeEditCommand` should extend `EditCommand`
* ** Alternative 1 (current choice):** `ResumeEditCommand` does not extend `EditCommand`, but extends `Command`. This design is chosen because `redit` is sufficiently different from `edit`. An `edit` command is intended to change the details of the resume such as its name, while `redit` is supposed to change the content that the resume holds.

** Pros: Reduce the size of responsibility for `EditResumeCommand`. Each command class now does one and only one thing so Single Responsibility Pricniple is observed.
** Cons: Unable to exploit polymorphism if there is similarity with the `EditCommand`. From user's point-of-view, it may be confusing to have both `redit` and `edit`.

image::ResumeEditCommandAlt1.png[]

* ** Alternative 2:** `ResumeEditCommand` extends `EditCommand`

** Pros: Some methods in `EditCommand` may be able to inherited by `ResumeEditCommand`, reducing code duplication.
** Cons: If the functionality of `ResumeEditCommand` is limited, it could have been combined with `EditCommand` entirely.

image::ResumeEditCommandAlt2.png[]

=== Implementation of `Command` classes
==== Current Implementation
Currently, there are several object `Type` which are subclasses of `Item`, namely `Resume`, `Internship`, `Skill`,
and `Project`.

Commands that are dependent on item `Type`, namely `EditCommand`, `AddCommand`, `DeleteCommand`, `FindCommand`,
`ListCommand`, and `ViewCommand` are implemented as abstract classes that inherits from `Command` and would have a
concrete classes that corresponds to each item `Type`. For example, `AddCommand` is an abstract class that
`AddInternshipCommand` and `AddSkillCommand` inherits from.

Commands that are not dependent on item `Type` (eg. `EditUserCommand`, `HelpCommand`) are implemented as concrete
classes that inherits from `Command`.

.Component `XYZCommand` is independent of `Type` whereas `ABCCommand` is dependent on `Type`.
image::CommandClassDiagram.png[]

==== Design Considerations
===== Aspect: Whether to separate the `ABCCommand` that is dependent on type into many `ABCItemCommand`
* ** Alternative 1 (current choice):** `ABCCommand` is separated into many `ABCItemCommand`.

** Pros: More OOP. Flexible behaviour of `ABCItemCommand` and can be easily changed as required. No
casing required. Each `ABCItemCommand` has it's own and distinct functionality.
** Cons: Many classes have to be maintained.

* ** Alternative 2: ** Do not separate `ABCCommand`.

** Pros: Only one command is required, regardless of number of items. Low overhead.
** Cons: Long `execute` method due to the need for handling the different item types. Item `Type` would also need to be stored.
Undesirable variable functionality of `execute` command depending on the `Type` field despite it being from the same class.
ie. `AddItem` can add `Internship` to the `Internship` list, or add `Skill` to `Skill` list.

****
*Conclusion:* We went with our current design because it allows for each command type to only have one distinct job which
is more in line with the object oriented programming paradigm of Single Responsibility Principle. Instead of having one single
class that that would need to change if implementation of any of the `Type` changes, our implementation ensures that
our many command classes would only have a single reason to change. Moreover, our current implementation also
reduces double work as `Parser` will not have to parse `Type` in the user input to create the `ABCCommand`, then only to
be switch-cased again in `ABCCommand`.
****
// end::redit[]
=== Me Feature
This feature allows a user to make changes and updates his/her user profile which is reflected by the user profile panel.
At the same time, it also allows user to personalise his/her experience using the app with certain sub-features. They are
elaborated below:

* Edit user profile image

* Edit user main data

* Input, store and generate motivational quotes

* Change background and font color

* Set reminders or take notes

==== Edit User Profile Image
This allows the specific user to input and update his/her user profile picture.

==== Edit User Main Data
This allows one specific user to modify and update user information that includes `name`, `phone`, `email1`, `github`,
`university`, `major`, `from`, `to`, `cap`.

Below is an example usage scenario and how the edit user data command works.

* User launches the application for the first time. The User Profile and Data will be initialized with the initial json
data stored.

image::user-default-data.png[]

* User executes `me n/NAME p/PHONE e/EMAIL g/GITHUB u/UNIVERSITY m/MAJOR f/FROM t/TO c/CAP` so as to update the Person
object currently stored in Model as well as Storage.

 me n/Nham Hung p/91608840 e/nhamhung.gttn@gmail.com g/nhamhung u/NUS m/CS f/10-2020 t/11-2020 c/5.0

* The Ui User Data Table will be updated accordingly.

image::user-data.png[]

Command sequence:

1. User type `me` command in the command box.
2. Command is executed by Logic Manager.
3. Command is parsed by `ResumeBookParser` which identifies what type of command it is. An `EditUserParser` is returned accordingly.
4. `EditUserParser` extracts out different components of the command into an `EditUserDescriptor` object and returns an `EditUserCommand`
with the `EditUserDescriptor` object which contains information on which attributes of user data is updated or kept unchanged.
5. `EditUserCommand` then calls `execute()` which first gets the existing user in Model as `userToEdit`. Then it creates a new
`editedUser` based on `EditUserDescriptor`. It will then update the current `userToEdit` in Model with `editedUser`. Afterwards,
a `CommandResult` is returned to Logic with data and feedback to be displayed to the user.
6. Feedback acknowledge is displayed by `ResultDisplay`. User profile changes are displayed by JavaFx `TableView`.

The following sequence diagram shows how the `me` feature allows user to edit the user profile:

image::MeSequenceDiagram.png[]

===== Design Considerations

*Aspect: Whether `EditUserCommand` should extend `EditCommand`*

* ** Alternative 1 (current choice):** `EditUserCommand` does not extend `EditCommand`, but extends `Command`
This design is chosen because while `EditCommand` takes into account the item index as all items are stored in a list in Model, `EditUserCommand`
only concerns with a single `Person` who is the sole user.

** Pros: Reduces unnecessary overhead for `EditUserCommand`.
** Cons: Unable to exploit polymorphism if there is similarity with the `EditCommand`.

* **Alternative 2: `EditUserCommand` extends `EditCommand`**

** Pros: Better utilise polymorphism and perhaps can be more intuitive as it is also a command to edit.

** Cons: Does not treat it as an entirely separate command with a distinct keyword `me` which is more intuitive for the user.

*Aspect: Whether to have both `AddUserCommand` and `EditUserCommand`*

* *Alternative 1 (current choice):* A default user data is initialized and displayed at first start-up. User can update it afterwards.
This design is chosen because `EditUserCommand` only concerns with a single `Person` object in the Model as the sole user. Hence
there is no need for `AddUserCommand` as `EditUserCommand` when executed always creates a new `Person` object to replace the
existing one and update the Model and Ui accordingly.

** Pros: Reduces unnecessary code duplication.
** Cons: User may expect to have `add` command intuitively.

* Alternative 2: Have both `AddUserCommand` and `EditUserCommand`

** Pros: User can intuitively treat `add` as adding in a new `user` and `edit` as just modifying an existing `user`.
** Cons: There will be code duplication and the one single user logic is not fully utilised to reduce code.

==== Store and Display Motivational Quotes
This allows the user to input and store motivational quotes. They are then able to display them at the user profile pane.

==== Set Personal Reminders and Take Notes
This allows the user to set reminders as well as taking notes for him/herself to further customize his/her interaction
with the app.

==== Change Background and Font Color
This allows the user to change the background and font color using rgb or hex color codes.

//tag::export[]
=== Export Resume feature
The Export Resume feature supports two main actions: previewing the content of a `Resume` item, and
then exporting it as a .pdf file.

==== rpreview: preview a `Resume`
===== Implementation
`rpreview` is supported by the new `Command`, `ResumePreviewCommand` and the additional method `Resume#getPreview()`
which return the content of the `Resume` in textual format.

Given below is an example usage scenario:

Step 1. The user launches the ResuMe application. After loading data from storage to the application memory, the list of
resumes in the ResumeBook could either contain some resumes, or is empty.

Step 2. The user executes `rpreview INDEX`. If the specified resume index is out of bound, ResuMe throws an error message.

Step 3. The application retrieves the correct `Resume` item and call `getPreview()` on that resume.

The following activity diagram summarises what happens when a user executes `rpreview` command:

image::ExportPreviewActivityDiagram.png[]


===== Design Considerations
===== Aspect: Where `rpreview` is displayed

* *Alternative 1 (current choice):* Display in the same panel as `view`
** Pros: No significant change to UI component.
** Cons: Multiple commands needed if user finds out about a typo in an item, wants to view the item in details,
fix the typo and then check the preview again to ensure there is no more error.

* *Alternative 2:* Create a separate UI panel to display the resume preview. Additionally, this panel could be implemented
such that it automatically updates when the content of the `Resume` item is edited.
** Pros: User can see the resume preview and the item detail panels at the same time, hence saving time switching between views.
** Cons: Too many panels could be confusing for the user to navigate. The space is also often wasted since user does not
need to use `rpreview` regularly.

****
*Conclusion:* Given that the application already has quite a number of panels (User Profile, Command Input,
Command Result, Item Detail and List View), alternative 1 is chosen to minimise the layout and improve on user experience.
The Command Result panel will display a confirmation message for any successful item edit, hence the user will not need
to call `rpreview` after each edit, reducing the number of switches between views.
****

==== rgen: generate a .pdf file from a `Resume`
===== Implementation
This feature utilises the external *iText* library. When using `rgen`, the user could specify the desired name of
the generated file, which will be saved in the root directory of the project.

`rgen` implements the following operations:

* `create(String)` and `create()` - initialises the .pdf file, either with the input `String` name specified by the user,
or with the same name as the `Resume` name if the file name is not specified.
* `addSection(String)` - starts a new section with the `String` name (e.g. "Internship").
* `populateSection(UniqueItemList)` and `insertItem(Item)` - populates the section with items in the same order as they
are in the `UniqueItemList`. When an `Item` is inserted, it is correctly formatted depending on the item type.

Given below is an example usage scenario:

Step 1. The user launches ResuMe. After loading data from storage to the application memory, the list of resumes in the
ResumeBook could either contain some resumes, or is empty.

Step 2. The user executes `rgen INDEX n/ FILE_NAME`. If the specified resume index is out of bound,
ResuMe throws an error message.

Step 3. The application retrieves the correct `Resume` item, create a new .pdf file and populates it with the corresponding
items inside the `Resume`.

The following activity diagram summarises what happens when a user executes `rgen` command:

image::ExportActivityDiagram.png[]

Detailed steps are shown in the sequence diagram below:

image::ExportSequenceDiagram.png[, 1000]

==== Design Considerations
===== Aspect: How `rgen` executes

* *Alternative 1 (current choice):* Generate .pdf file by iteratively reading and inserting details of `Item` from inside the `Resume` itself.
** Pros: Better control of the output layout, as the position and formatting of each section could be set individually.
Additionaly, `rgen` is dynamic, in the sense that even without calling `rpreview` every time, the generated file will be
consistent with any item update.
** Cons: Coupled with `rpreview`, the content of a `Resume` must be read twice every time the user wishes to export.

* *Alternative 2:* Generate .pdf file directly from the previewed text output by `rpreview`
** Pros: Faster `rgen`
** Cons: Limited formatting options (font and font size at most) since the whole document is input as one long string.
`rgen` implemented this way is also static, and might not reflect the most updated content if there are item changes
after `rpreview` is called.

****
*Conclusion:* Alternative 1 is chosen because each resume is not likely to hold more than 20 items, hence the cost
of reading its content twice (once during `rpreview` and once during `rgen`) is relatively small. Choosing alternative 1
will further allows the application to have more control when formatting the output file, and leaving room for potential
extended features (e.g. allow user to choose from a variety of pre-defined resume templates).
****
end::export[]

// tag::undoredo[]
=== [Proposed] Undo/Redo feature
==== Implementation

The undo/redo mechanism is facilitated by `VersionedResumeBook`.
It extends `ResumeBook` with an undo/redo history, stored internally as an `ResumeBookStateList` and `currentStatePointer`.
Additionally, it implements the following operations:

* `VersionedResumeBook#commit()` -- Saves the current resume book state in its history.
* `VersionedResumeBook#undo()` -- Restores the previous resume book state from its history.
* `VersionedResumeBook#redo()` -- Restores a previously undone resume book state from its history.

These operations are exposed in the `Model` interface as `Model#commitResumeBook()`, `Model#undoResumeBook()` and `Model#redoResumeBook()` respectively.

Given below is an example usage scenario and how the undo/redo mechanism behaves at each step.

Step 1. The user launches the application for the first time. The `VersionedResumeBook` will be initialized with the initial resume book state, and the `currentStatePointer` pointing to that single resume book state.

image::UndoRedoState0.png[]

Step 2. The user executes `delete 5 i/ res` command to delete the 5th resume in the resume book. The `delete` command calls `Model#commitResumeBook()`, causing the modified state of the resume book after the `delete 5 i/ res` command executes to be saved in the `resumeBookStateList`, and the `currentStatePointer` is shifted to the newly inserted resume book state.

image::UndoRedoState1.png[]

Step 3. The user executes `add i/ res n/ Summer Resume ...` to add a new resume. The `add` command also calls `Model#commitResumeBook()`, causing another modified resume book state to be saved into the `resumeBookStateList`.

image::UndoRedoState2.png[]

[NOTE]
If a command fails its execution, it will not call `Model#commitResumeBook()`, so the resume book state will not be saved into the `resumeBookStateList`.

Step 4. The user now decides that adding the resume was a mistake, and decides to undo that action by executing the `undo` command. The `undo` command will call `Model#undoResumeBook()`, which will shift the `currentStatePointer` once to the left, pointing it to the previous resume book state, and restores the resume book to that state.

image::UndoRedoState3.png[]

[NOTE]
If the `currentStatePointer` is at index 0, pointing to the initial resume book state, then there are no previous resume book states to restore. The `undo` command uses `Model#canUndoResumeBook()` to check if this is the case. If so, it will return an error to the user rather than attempting to perform the undo.

The following sequence diagram shows how the undo operation works:

image::UndoSequenceDiagram.png[]

NOTE: The lifeline for `UndoCommand` should end at the destroy marker (X) but due to a limitation of PlantUML, the lifeline reaches the end of diagram.

The `redo` command does the opposite -- it calls `Model#redoResumeBook()`, which shifts the `currentStatePointer` once to the right, pointing to the previously undone state, and restores the resume book to that state.

[NOTE]
If the `currentStatePointer` is at index `resumeBookStateList.size() - 1`, pointing to the latest resume book state, then there are no undone resume book states to restore. The `redo` command uses `Model#canRedoResumeBook()` to check if this is the case. If so, it will return an error to the user rather than attempting to perform the redo.

Step 5. The user then decides to execute the command `list i/ res`. Commands that do not modify the resume book, such as `list`, will usually not call `Model#commitResumeBook()`, `Model#undoResumeBook()` or `Model#redoResumeBook()`. Thus, the `resumeBookStateList` remains unchanged.

image::UndoRedoState4.png[]

Step 6. The user executes `clear`, which calls `Model#commitResumeBook()`. Since the `currentStatePointer` is not pointing at the end of the `resumeBookStateList`, all resume book states after the `currentStatePointer` will be purged. We designed it this way because it no longer makes sense to redo the `add i/ res ...` command. This is the behavior that most modern desktop applications follow.

image::UndoRedoState5.png[]

The following activity diagram summarizes what happens when a user executes a new command:

image::CommitActivityDiagram.png[]

==== Design Considerations

===== Aspect: How undo & redo executes

* **Alternative 1 (current choice):** Saves the entire resume book.
** Pros: Easy to implement. Easy to understand.
** Cons: May have performance issues in terms of memory usage.
* **Alternative 2:** Individual command knows how to undo/redo by itself.
** Pros: Will use less memory (e.g. for `delete`, just save the item being deleted).
** Cons: We must ensure that the implementation of each individual command is correct. It is further complicated by the fact that
there is an `add`, `delete`, and `edit` command for each of item type. Also, Separation of Concerns Principle is violated as in essence, the `undo()` method of a command
is doing more than what the command is responsible for, e.g. undoing a `delete` command is essentially performing an `add` command.


===== Aspect: Data structure to support the undo/redo commands

* **Alternative 1 (current choice):** Use a list to store the history of resume book states.
** Pros: Very straightforward. Developers, even the novice ones, can easily understand and pick up if they wish to improve upon our application.
** Cons: Logic is duplicated twice. For example, when a new command is executed, we must remember to update both `HistoryManager` and `VersionedResumeBook`.
* **Alternative 2:** Use `HistoryManager` for undo/redo. `HistoryManager` will contain two stacks: `UndoStack` and `RedoStack`. We push a command into the former stack
when it is executed; when an `undo` is performed, we pop the top of the `UndoStack` and store the command in the `RedoStack`.
** Pros: We do not need to maintain a separate list, and just reuse what is already in the codebase. We also just need to store the history of commands as opposed to the entire
resume book.
** Cons: Handling of the stacks can be confusing, especially since there are commands that make no change to the model and thus are not (and should not be) stored. `edit` and `delete` require
the old-versioned item to be stored as well so that it can be restored while `add` does not, thereby affecting consistency.
// end::undoredo[]

// tag::dataencryption[]
=== [Proposed] Data Encryption

_{Explain here how the data encryption feature will be implemented}_

// end::dataencryption[]

=== Logging

We are using `java.util.logging` package for logging. The `LogsCenter` class is used to manage the logging levels and logging destinations.

* The logging level can be controlled using the `logLevel` setting in the configuration file (See <<Implementation-Configuration>>)
* The `Logger` for a class can be obtained using `LogsCenter.getLogger(Class)` which will log messages according to the specified logging level
* Currently log messages are output through: `Console` and to a `.log` file.

*Logging Levels*

* `SEVERE` : Critical problem detected which may possibly cause the termination of the application
* `WARNING` : Can continue, but with caution
* `INFO` : Information showing the noteworthy actions by the App
* `FINE` : Details that is not usually noteworthy but may be useful in debugging e.g. print the actual list instead of just its size

[[Implementation-Configuration]]
=== Configuration

Certain properties of the application can be controlled (e.g user prefs file location, logging level) through the configuration file (default: `config.json`).

== Documentation

Refer to the guide <<Documentation#, here>>.

== Testing

Refer to the guide <<Testing#, here>>.

== Dev Ops

Refer to the guide <<DevOps#, here>>.

[appendix]
== Product Scope

*Target user profile*:

* has a need to manage a significant number of contacts
* prefer desktop apps over other types
* can type fast
* prefers typing over mouse input
* is reasonably comfortable using CLI apps

*Value proposition*: manage contacts faster than a typical mouse/GUI driven app

[appendix]
== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="59%",cols="22%,<23%,<25%,<30%",options="header",]
|=======================================================================

|Priority |As a ... |I want to ... |So that I can...

|`* * *` |user |manage and customise different resumes |use different resumes for different companies

|`* * *` |user |create a resume file |print it

|`* * *` |user |add to and remove 'items' from a certain resume |

|`* * *` |user |add, edit, and remove 'items' |

|`* * *` |user |preview my resume |check for mistakes in a resume before generating it

|`* * *` |user | search for items containing certain keywords | find items that are relevant to my current need

|`* *` |user |see all the 'items' I've added |

|`* *` |user |see all my resumes |manage them in a centralised location

|`* *` |user |categorise the 'items' I've added |to ensure my resume will have 'items' of different types

|`* *` |new user |view more information about various commands |learn to use new commands

|`*` |careless user |undo my previous command | skip the step of manually editing or deleting them.

|`*` |busy user |auto-format my resumes |


|=======================================================================

_'items' refers to a resume field of type personal details, project, education, skills, internship, and achievement._

_{More to be added}_

[appendix]
== Use Cases

(For all use cases below, the *System* is the `ResumeBook` and the *Actor* is the `user`, unless specified otherwise)

[discrete]
=== Use case: Edit an item

*MSS*

1.  User requests to list all items or only items of a specific `TYPE`
2.  ResuMe shows a list of corresponding items
3.  User checks for the `ID` of a specific item in the list to edit
4.  User requests to edit a specific item in the list
5.  ResuMe updates that item and displays edited item to user
+
Use case ends.

*Extensions*

[none]
* 3a. The `ID` given by user does not match any item of type
+
[none]
** 3a1. ResuMe shows an error message
+

[discrete]
=== Use case: Find item(s)

*MSS*

1.  User enters `find KEYWORD` without specifying a `TYPE`
2.  ResuMe displays all items whose names contain the `KEYWORD`
3.  If user enters `find -TYPE KEYWORD`
4.  ResuMe displays only items of the `TYPE` whose names contain the `KEYWORD`
+
Use case ends.

*Extensions*

[none]
* 1a. None of the items contain the `KEYWORD`.
+
[none]
** 1a1. ResuMe shows an error message.
+

[discrete]
=== Use case: Delete an item

*MSS*

1.  User requests to list all items or only items of a specific `TYPE`
2.  ResuMe shows a list of corresponding items
3.  User checks for the `ID` of a specific item in the list to delete
4.  User requests to edit a specific item in the list
5.  ResuMe deletes that item from the list and displays deleted item to user
+
Use case ends.

*Extensions*

* 2a. The list is empty.
+
[none]
** Use case ends.
+
* 3a. The given `ID` is invalid.
** 3a1. ResuMe shows an error message.
[none]
** Use case resumes at step 2.


_{More to be added}_

[appendix]
== Non Functional Requirements

.  Should work on any <<mainstream-os,mainstream OS>> as long as it has Java `11` or above installed.
.  Should work on both 32-bit and 64-bit environments.
.  Should be able to support up to 1000 users without a noticeable sluggishness in performance for typical usage.
.  Should be able to support at least 5 resumes per user, 20 items per resume, and 100 resume items in total.
.  Data should be stored locally such that users can access them (either through the application or directly by access
the data file) without any network connection.
.  Should response within two seconds for a normal item query, and five seconds for a pdf generation request.
.  A user with some familiarity with Command Line Interface (CLI) should be able to accomplish most of the tasks faster
using commands than using the mouse to navigate the Graphic User Interface (GUI).

_{More to be added}_

[appendix]
== Glossary

[[mainstream-os]] Mainstream OS::
Windows, Linux, Unix, OS-X

[[private-contact-detail]] Private contact detail::
A contact detail that is not meant to be shared with others

[appendix]
== Product Survey

*Product Name*

Author: ...

Pros:

* ...
* ...

Cons:

* ...
* ...

[appendix]
== Instructions for Manual Testing

Given below are instructions to test the app manually.

[NOTE]
These instructions only provide a starting point for testers to work on; testers are expected to do more _exploratory_ testing.

=== Launch and Shutdown

. Initial launch

.. Download the jar file and copy into an empty folder
.. Double-click the jar file +
   Expected: Shows the GUI with a set of sample contacts. The window size may not be optimum.

. Saving window preferences

.. Resize the window to an optimum size. Move the window to a different location. Close the window.
.. Re-launch the app by double-clicking the jar file. +
   Expected: The most recent window size and location is retained.

_{ more test cases ... }_

=== Deleting a person

. Deleting a person while all persons are listed

.. Prerequisites: List all persons using the `list` command. Multiple persons in the list.
.. Test case: `delete 1` +
   Expected: First contact is deleted from the list. Details of the deleted contact shown in the status message. Timestamp in the status bar is updated.
.. Test case: `delete 0` +
   Expected: No person is deleted. Error details shown in the status message. Status bar remains the same.
.. Other incorrect delete commands to try: `delete`, `delete x` (where x is larger than the list size) _{give more}_ +
   Expected: Similar to previous.

_{ more test cases ... }_

=== Saving data

. Dealing with missing/corrupted data files

.. _{explain how to simulate a missing/corrupted file and the expected behavior}_

_{ more test cases ... }_
